In your groups, answer the following questions.
No need to report the answers to me --
this is just for practice.

I will be dropping in and out of rooms to facilitate to the discussions and in
case you have any questions.
Think of it like me walking around the classroom and listening to different
groups.
Again, this isn't meant to be for a grade,
so don't be concerned about giving a wrong answer even if I am in the room.
You can also flag me down in Zoom if you have a question even if I'm not in the
room
(I think the button in Zoom looks like a question mark).

# Questions

How would you describe the difference between syntax and semantics?
Give an example of a syntax rule.
Give an example of a description of a program's semantics.

Two of the tasks a compiler must perform are breaking a text up into lexemes
and creating a parse tree.
Which do you think it does first?
Why?

For the next few questions,
there is no one correct answer because I haven't specified exactly what the
rules for lexemes are.
However, some sets of rules are more sensible than others.
Use your best judgement,
and take it as an opportunity to have a discussion.

Break this sentence into lexemes:
`let programmingLanguages = (good_fun)^2`

How might you categorize the lexemes you found into tokens?

(Textbook 3.11)
Consider the following grammar:
```
<S> -> <A>a<B>b
<A> -> <A>b | b
<B> -> a<B> | a
```
Which of the following sentences are in the language generated by this grammar?
Either give a derivation or explain why it is not possible.
* baab
* bbbab
* bbaaaaaS
* bbaab

For the next few questions,
use this example grammar from your textbook.
```
<assign> -> <id> = <expr>
<id> -> A | B | C
<expr> -> <expr> + <term>
        | <term>
<term> -> <term> * <factor>
        | <factor>
<factor> -> ( <expr> )
          | <id>
```

(Textbook 3.7)
If the following sentence is valid in the given grammar,
derive it and draw a parse tree for the sentence.
`A = B * (C * (A + B))`

If the following sentence is valid in the given grammar,
derive it and draw a parse tree for the sentence.
`C = (A + B) * (A * B)`

Given the parse tree below for an unknown grammar, which happens first,
the addition or the multiplication?
How do you know?
```
    <expression>
    /    |      \
  <id>   =      <expression>
   |            /     |     \
   A          <id>    +     <expression>
               |           /      |      \
               B          (  <expression> )
                            /     |      \
                         <id>     *      <id>
                          |                |
                          C                D
```

Give one possible set of grammar rules that could have generated the tree
above.
Is your grammar ambiguous?
If so, find an example to demonstrate.

What is the problem with having two parse trees for the same sentence?

Here is an example grammar based on Lisp
(actually, based on on a
[Wikipedia example](https://en.wikipedia.org/wiki/Programming_language#Syntax)
that was based on Lisp):
```
<expression> -> <atom>
<expression> -> <list>
<atom> -> <number>
<atom> -> <symbol>
<number> -> <digit><number>
<number> -> <digit>
<digit> -> 0
<digit> -> 1
...
<digit> -> 9
<symbol> -> <letter><symbol>
<symbol> -> <letter>
<letter> -> a
<letter> -> b
...
<letter> -> z
<list> -> '(' expression_list ')'
<expression_list> -> <expression><expression_list>
<expression_list> -> <expression>
<expression_list> -> " " (blank space)
```
Rewrite this using the variant of EBNF covered in the lectures.
The variant added `( A | B )` for OR,
`[]` for optional parts,
and `{}` for parts that are repeated 0 or more times.

Using your EBNF form or the original form
(it should make no difference),
write a few non-trivial sentences is the language.
It's up to you what non-trivial means.

(Textbook 3.2b)
Write an EBNF description of Java method call statements
(e.g., `Sound woof = fido.bark()`).
You'll need to think about which parts of the statements are required and which
are optional.
Don't bother going all the way down to characters --
stop at convenient tokens
(e.g., you can stop at the <identifiers> token without giving a rule defining
it).
If you are having trouble,
start by making some simplifying assumptions and writing the description for
the simplified grammar.
For example, you could assume that the method takes no arguments.

# Note

"The static semantics defines restrictions on the structure of valid texts that
are hard or impossible to express in standard syntactic formalisms."
~ "Programming language", *Wikipedia*, retrieved from
https://en.wikipedia.org/wiki/Programming_language#Static_semantics
on September 25, 2020.
